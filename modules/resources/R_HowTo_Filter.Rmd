---
title: "Filter or Subset Data in R"
description: |
  How to make a data frame with only some individuals from a larger data frame.
output:
  distill::distill_article:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, comment="#R>  ")
```

There are many examples during this course where a subset of a data frame will be required for an exercise. Creating a subset from a larger data frame is called "filtering" and uses `filter()` from the `dplyr` package, which is loaded automatically with `NCStats`.

<aside>
Make sure to load `NCStats` with `library(NCStats)`
</aside>

```{r message=FALSE, warning=FALSE}
library(NCStats)
```

Example data used here is from Mirex.csv [[data](https://raw.githubusercontent.com/droglenc/NCData/master/Mirex.csv), [meta](https://raw.githubusercontent.com/droglenc/NCData/master/Mirex_meta.txt)], which is loaded below.

```{r}
Mirex <- read.csv("https://raw.githubusercontent.com/droglenc/NCData/master/Mirex.csv")
str(Mirex)
```

The "levels" of `species` and `year` are shown below (to aid understanding their use below).

```{r}
unique(Mirex$species)
unique(Mirex$year)
```

&nbsp;

# The `filter()` Function
The `filter()` function requires two arguments. The first argument is the data frame from which the subset should be drawn. The second argument is a condition statement that describes how the subset should be drawn from the original data frame. For example, the condition statement will be R code that says to select all cohos from the species variable, all fish that had a weight greater than 5 kg, or all years between 1982 and 1992. The condition statement will usually start with the name of a variable, followed by an "operator," and then "values" of the variable (Table \@ref(tab:filterComps)). Specific types of conditions statement are explained in the following sections.

<aside>
Results of `filter()` are saved to an object for future use (i.e., you filtered for a reason).

Examine the new data frame after filtering to ensure that it contains the data you intended.
</aside>

```{r filterComps, echo=FALSE}
tmp <- data.frame(
  c('`var==value`','`var!=value`','`var %in% c(value1,value2)`',
    '`var`>`value`','`var`>=`value`','`var`<`value`','`var`<=`value`',
    'condition1,condition2','condition1 | condition2'),
  c('All rows where `var` **IS equal** to `value`',
    'All rows where `var` **is NOT equal** to `value`',
    'All rows where `var` **IS IN** vector of `value`s^[`value` should be a character, factor, or integer.]',
    'All rows where `var` is **greater than** `value`^[`value` must be numeric.]',
    'All rows where `var` is **greater than or equal to** `value`^[`value` must be numeric.]',
    'All rows where `var` is **less than** `value`^[`value` must be numeric.]',
    'All rows where `var` is **less than or equal to** `value`^[`value` must be numeric.]',
    'All rows where **BOTH** conditions are true',
    'All rows where **ONE or BOTH** conditions are true^[Note that this "or" operator is a "vertical line"" which is typed with the shift-backslash key.]')
)
names(tmp) <- c("Comparison Operator",
                "Rows Returned from Original Data Frame")
knitr::kable(tmp,booktabs=TRUE,caption="Comparison operators used in `filter()` and their results. Note that `var` generically represents a variable in the original data frame and `value` is a generic value or level. Both `var` and `val` would be replaced with specific items (see examples in following sections).") %>%
  kableExtra::kable_classic(full_width=FALSE,html_font="Cambria")
```

&nbsp;

# Isolating One Group
One group can be isolated from the original data frame using the `==` operator. For example, the code below select all `coho`s from the `species` variable.

<aside>
**Two equals signs** are used in a condition for "is it equal to."

Values after the "operator" must be in quotes for categorical variables.
</aside>

```{r}
cohos <- filter(Mirex,species=="coho")
unique(cohos$species)  ## CHECK - should be just coho
```

&nbsp;

# Isolating Two Groups
Two groups can be isolated from the original data using the `%in%` operator. For example, the code below selects all individuals that were in either 1986 or 1996.

<aside>
Values after the "operator" are not in quotes for quantitative variables.
</aside>

```{r}
yr86n96 <- filter(Mirex,year %in% c(1986,1996))
unique(yr86n96$year)  ## CHECK - should be just 1986 and 1996
```

&nbsp;

# Eliminating One Group
A group can be eliminated (thus, isolating all of the other groups) with the `!=` operator. For example, the code below eliminates all individuals that were not `coho`s (leaving just `chinook` in this example).

```{r}
notcoho <- filter(Mirex,species!="coho")
unique(notcoho$species)  ## CHECK - should not include coho
```

&nbsp;

# Isolating Relative to a Quantitative Variable
Individuals may be selected based on the relative value of a quantitative variable using obvious operators. For example, the code below selects all fish that weighed more than 5 kg.

```{r}
heavier5kg <- filter(Mirex,weight>5)
min(heavier5kg$weight)  ## CHECK - should be greater than 5
```

Similarly the code below selects all fish with a mirex concentration less than or equal to 0.2.

```{r}
mirexlt2 <- filter(Mirex,mirex<=0.2)
max(mirexlt2$mirex)  ## CHECK - should not be greater than 0.2
```

&nbsp;

# Two Conditions
### Must Have Both
Individuals that meet both of two conditions (i.e., **must** have this **and** that) are selected by separating the two conditions with a comma in `filter()`. For example, the code below selects `coho`s with a `weight` less than 1 kg.

```{r}
smallcoho <- filter(Mirex,species=="coho",weight<1)
smallcoho  ## CHECK -- should be all coho and all weights less than 1
```

### Can Have Either
Individuals that meet one or both of two conditions (i.e., **can** have this **or** that) are selected by separating the two conditions with a `|` in `filter()`. For example the code below selects fish from 1992 or that had a weight greater than or equal to 13 kg.

```{r}
weird <- filter(Mirex,year==1992 | weight>=13)
weird
```
